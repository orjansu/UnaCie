
module FileUtils
  ( exportToFile     -- Export output to a specified file, check for success.
  , getFileName      -- Get a filename if exists.
  , parseFile        -- Parse a file with a given parser.
  , parseFile'       -- As above but string error messages.
  , parseScriptFile  -- Parse a script file with a given script parser.
  ) where 

import CmdAST        (RawCmd)
import CmdError      (CmdError(..))
import PrintSettings (fileLineWidth)

import Control.Monad.Extra    (ifM)
import Control.Monad.IO.Class (liftIO)
import Data.Time              (defaultTimeLocale, formatTime, getCurrentTime)
import IndentationParserLib   (Parser, runParser)
import System.Directory       (doesFileExist)     
import System.FilePath.Posix  (takeBaseName)

{-
  Information:
  -----------------------------------------------------------------------------
  - Helper functions for file handling.
-}

-- Get the current date/time etc.
dateStamp :: IO String
dateStamp  = fmap (formatTime defaultTimeLocale "%d-%m-%Y") getCurrentTime

-- Export some output to a given filepath, not sure how to check for success
-- other than to check that the file exists after writing?
exportToFile :: FilePath -> [String] -> IO (Maybe CmdError)
exportToFile fp xss = do 

  -- Add a date stamp.
  ds <- dateStamp
  let stamp = "-- Generated by UNIE on: " ++ ds ++ " "
      fill  = replicate (fileLineWidth - length stamp) '-'
      sep   = replicate fileLineWidth '-'
  writeFile fp (unlines $ xss ++ ["", "", sep, stamp ++ fill])  

  -- Check file exists to see if writing was successful.
  ifM (doesFileExist fp) 
      (return Nothing)
      (return $ Just $ FileErr "invalid filepath.")

-- Attempt to parse a file using a given parser.
parseFile :: FilePath -> Parser a -> IO (Either CmdError a)
parseFile fp parser = 
  ifM (doesFileExist fp)
      (liftIO (readFile fp) >>= \ss ->
       case runParser parser ss of
        Just x  -> return $ Right x
        Nothing -> return $ Left $ FileErr "could not parse file.")
     (return $ Left $ FileErr "invalid filepath.")

-- As above but string error message.
parseFile' :: FilePath -> Parser a -> IO (Either String a)
parseFile' fp parser = 
  ifM (doesFileExist fp)
      (liftIO (readFile fp) >>= \ss ->
       case runParser parser ss of
        Just x  -> return $ Right x
        Nothing -> return $ Left $ "could not parse file.")
     (return $ Left $ "invalid filepath.")

-- Attempt to a parse a command script file using a given script parser
-- of type 'String -> Either CmdError [RawCmd]'. 
parseScriptFile :: FilePath 
                   -> (String -> Either CmdError [RawCmd]) 
                   -> IO (Either CmdError [RawCmd])
parseScriptFile fp parser = 
  ifM (doesFileExist fp) 
      (readFile fp >>= return . parser)
      (return $ Left $ FileErr "invalid filepath.")

getFileName :: FilePath -> IO (Maybe String)
getFileName fp = ifM (doesFileExist fp)
                     (return $ Just $ takeBaseName fp)
                     (return Nothing) 