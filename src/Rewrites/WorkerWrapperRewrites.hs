{-# LANGUAGE LambdaCase #-}

module WorkerWrapperRewrites where

import CtxAST
import CtxPatAST hiding (hasHoles)
import KureMonad
import KureContext
import CtxUtils
import CtxEqLib
import CtxKind
import CtxGen
import CtxPatMatch
import CtxCheck
import TransUtils
import Subst
import KureExtra

import Language.KURE
import Control.Arrow
import Data.List

{-
  <TO-DO>: - These should be generalised from R.

  Information:
  -----------------------------------------------------------------------------
  - Rewrites relating to the laws of the worker/wrapper improvement theorem.
  - Some are implemented as assumptions, these are just really for proof
    of concept, they don't do anything interesting.
-}

-- w/w assumption (A): --------------------------------------------------------
-- Abs[Rep[x]] <~~> x, for value contexts Abs, Rep

wwAssAGenT :: CtxEqLib -> T Ctx [(Ctx, Ctx, Term)]
wwAssAGenT lib = prefixFailMsg "wwAssAGenT failed: " $
  genCtxsFvBvDisjoint varOnlySubst [VAL,VAL] lib >>> liftT genTrips

wwAssAMatchT :: CtxEqLib -> CtxPat -> T Ctx [(Ctx, Ctx, Term)]
wwAssAMatchT lib pctx = prefixFailMsg "wwAssAMatchT failed: " $ do
  -- All valid options.
  gens <- wwAssAGenT lib
  -- All contexts generated by pattern matching
  matches <- genTrips <$> (liftT $ ctxPatGen [pctx])
  -- Return their intersection.
  return $ (gens `intersect` matches)

wwAssAR :: CtxEqLib -> Ctx -> Ctx -> R Ctx
wwAssAR lib c1 c2 = prefixFailMsg "wwAssAR failed: " $ do
  -- All valid options.
  gens <- wwAssAGenT lib
  case filter (\(c1', c2', _) -> c1 == c1' &&
                                 c2 == c2') gens of
    [(_, _, ns@Var{})] -> return ns
    _ -> fail "invalid context(s)."


-- unw/w assumption (A): --------------------------------------------------------
-- x <~~> Abs[Rep[x]], for value contexts Abs, Rep

unwwAssAR :: CtxEqLib -> Ctx -> Ctx -> R Ctx
unwwAssAR lib c1 c2 = prefixFailMsg "unwwAssAR failed: " $ do
  if checkCtxKind lib c1 VAL &&
     checkCtxKind lib c2 VAL &&
     hasHoles c1 &&
     hasHoles c2
  then do
    ns <- varNameT
    bvs <- constT $ applyT boundVarsHolesListT emptyKureContext [c1, c2]
    guardMsg (ns `notElem` bvs) $ "'" ++ ns ++ "'not free in contexts."
    let sub = substCtx (Var ns) c2
    constT $ applyR (capAvoidSubstCtxR sub) emptyKureContext c1
  else fail "invalid contexts."


--- We use (B) in the paper, so thought (C) would be more fun to implement
-- here

-- w/w assumption (C): --------------------------------------------------------
-- let x = Abs[Rep[F[x]] in x <~~> let x = F[x] in x,
-- for value contexts Abs, Rep, F

wwAssCGenT :: CtxEqLib -> T Ctx [(Ctx, Ctx, Ctx, Term)]
wwAssCGenT lib = prefixFailMsg "wwAssCGenT failed: " $ idR >>= \case
  Let [Bind ns body _] (Var ns') | ns == ns' -> do
    constT $ applyT (genCtxsFvBvDisjoint (specSubstGen $ Var ns) [VAL,VAL,VAL] lib
     >>> liftT genQuads) emptyKureContext body
  _ -> fail "not a let of the correct form."

wwAssCMatchT :: CtxEqLib -> CtxPat -> T Ctx [(Ctx, Ctx, Ctx, Term)]
wwAssCMatchT lib pctx =   prefixFailMsg "wwAssCMatchT failed: " $ do
  -- All valid options.
  gens <- wwAssCGenT lib
  -- All contexts generated by pattern matching
  matches <- genQuads <$> (liftT $ ctxPatGen [pctx])
  -- Return their intersection.
  return $ (gens `intersect` matches)

wwAssCR :: CtxEqLib -> Ctx -> Ctx -> Ctx -> R Ctx
wwAssCR lib c1 c2 c3 = prefixFailMsg "wwAssCR failed: " $ do
  -- All valid options.
  gens <- wwAssCGenT lib
  case filter (\(c1', c2', c3', _) -> c1 == c1' &&
                                      c2 == c2' &&
                                      c3 == c3') gens of
    [(_, _, _, Var sub)] -> idR >>= \case
      Let [Bind ns _ _] (Var ns')
       | ns == ns' &&
         ns == sub -> return $ Let [Bind ns (substCtx (Var ns) c3) 0] (Var ns)
      _ -> fail "invalid context(s)."
    _ -> fail "invalid context(s)."


-- unw/w assumption (C): ------------------------------------------------------
-- let x = F[x] in x <~> let x = Abs[Rep[F[x]] in x, for value contexts Abs, Rep, F

unwwAssCGenT :: CtxEqLib -> T Ctx [(Ctx, Term)]
unwwAssCGenT lib = prefixFailMsg "unwwAssCGenT failed: " $ idR >>= \case
  Let [Bind ns body _] (Var ns') | ns == ns' -> do
    constT $ applyT (genCtxsFvBvDisjoint (specSubstGen $ Var ns) [VAL] lib
     >>> liftT genPairs) emptyKureContext body
  _ -> fail "not a let of the correct form."

unwwAssCMatchT :: CtxEqLib -> CtxPat -> T Ctx [(Ctx, Term)]
unwwAssCMatchT lib pctx =   prefixFailMsg "unwwAssCMatchT failed: " $ do
  -- All valid options.
  gens <- unwwAssCGenT lib
  -- All contexts generated by pattern matching
  matches <- genPairs <$> (liftT $ ctxPatGen [pctx])
  -- Return their intersection.
  return $ (gens `intersect` matches)

unwwAssCR :: CtxEqLib -> Ctx -> Ctx -> Ctx -> R Ctx
unwwAssCR lib c1 c2 c3 = prefixFailMsg "unwwAssCR failed: " $ do
  guardMsg (checkCtxKind lib c1 VAL &&
            checkCtxKind lib c2 VAL &&
            hasHoles c1 &&
            hasHoles c2) "invalid context(s)."
  gens <- unwwAssCGenT lib
  case filter (\(c3', _) -> c3 == c3') gens of
    [(_, Var sub)] -> idR >>= \case
      Let [Bind ns _ _] (Var ns') | ns == ns' && ns == sub -> do
        let sub = substCtx (Var ns) c3
        sub2 <- constT $ applyR (capAvoidSubstCtxR sub) emptyKureContext c2
        sub3 <- constT $ applyR (capAvoidSubstCtxR sub2) emptyKureContext c1
        return $ Let [Bind ns sub3 0] (Var ns)
      _ -> fail "invalid context(s)."
    _ -> fail "invalid context(s)."


-- rolling rule: --------------------------------------------------------------
-- let { x = F[G[x]] } in G[x] <~~> let { x = G[F[x]] } in x

rollingRuleGenT :: CtxEqLib -> T Ctx [(Ctx, Ctx, Term)]
rollingRuleGenT lib = prefixFailMsg "rollingRuleGenT failed: " $ idR >>= \case
  Let [Bind ns body _] letBody -> do
    opts <- constT $ applyT (genCtxsFvBvDisjoint (specSubstGen $ Var ns) [VAL, VAL] lib
       >>> liftT genTrips) emptyKureContext body
    return $ filter (\(_, c2, sub) -> substCtx sub c2 == letBody) opts
  _ -> fail "not a let of the correct form."

rollingRuleMatchT :: CtxEqLib -> CtxPat -> T Ctx [(Ctx, Ctx, Term)]
rollingRuleMatchT lib pctx = prefixFailMsg "rollingRuleMatchT failed: " $ do
  -- All valid options.
  gens <- rollingRuleGenT lib
  -- All contexts generated by pattern matching
  matches <- genTrips <$> (liftT $ ctxPatGen [pctx])
  -- Return their intersection.
  return $ (gens `intersect` matches)

rollingRuleR :: CtxEqLib -> Ctx -> Ctx -> R Ctx
rollingRuleR lib c1 c2 = prefixFailMsg "rollingRuleR failed: " $ do
  -- All valid options.
  gens <- rollingRuleGenT lib
  case filter (\(c1', c2', _) -> c1 == c1' &&
                                 c2 == c2') gens of
    [(c1, c2, Var ns)] -> do
      let sub1 = substCtx (Var ns) c1
      sub2 <- constT $ applyR (capAvoidSubstCtxR sub1) emptyKureContext c2
      return $ Let [Bind ns sub2 0] (Var ns)
    _ -> fail "invalid context(s)."


---- unrolling rule: ----------------------------------------------------------
-- let { x = G[F[x]] } in x <~~> let { x = F[G[x]] } in G[x]

unrollingRuleGenT :: CtxEqLib -> T Ctx [(Ctx, Ctx, Term)]
unrollingRuleGenT lib = prefixFailMsg "unrollingRuleGenT failed: " $ idR >>= \case
  Let [Bind ns body _] (Var ns') | ns == ns' ->
   constT $ applyT (genCtxsFvBvDisjoint (specSubstGen $ Var ns) [VAL, VAL] lib
       >>> liftT genTrips) emptyKureContext body
  _ -> fail "not a let of the correct form."

unrollingRuleMatchT :: CtxEqLib -> CtxPat -> T Ctx [(Ctx, Ctx, Term)]
unrollingRuleMatchT lib pctx = prefixFailMsg "unrollingRuleMatchT failed: " $ do
  -- All valid options.
  gens <- unrollingRuleGenT lib
  -- All contexts generated by pattern matching
  matches <- genTrips <$> (liftT $ ctxPatGen [pctx])
  -- Return their intersection.
  return $ (gens `intersect` matches)

unrollingRuleR :: CtxEqLib -> Ctx -> Ctx -> R Ctx
unrollingRuleR lib c1 c2 = prefixFailMsg "unrollingRuleR failed: " $ do
  -- All valid options.
  gens <- unrollingRuleGenT lib

  case filter (\(c1', c2', _) -> c1 == c1' &&
                                 c2 == c2') gens of
    [(c1, c2, Var ns)] -> do
      let sub1 = substCtx (Var ns) c1
      sub2 <- constT $ applyR (capAvoidSubstCtxR sub1) emptyKureContext c2
      return $ Let [Bind ns sub2 0] $ substCtx (Var ns) c1
    _ -> fail "invalid context(s)."
