
module CmdError where

import InterState    (InterState)
import CmdLexUtils   (LexError, Pos)
import Utils         (singleton, allEq)
import PPLib         ( highlightError, highlightCritError
                     , squashString, unlines', indentHighlightError )
import PrintSettings (terminalLineWidth)
import Utils         (stripSpace)

import Data.List  (isInfixOf, nub)
import Data.List.Split (splitOn)
import Data.Maybe (fromMaybe)

{-
  <TO-DO>: - N/A

  Information:
  -----------------------------------------------------------------------------
  - Command errors that can be reported by UNIE at different stages of
    (attempting to) executing a command input by the user on the command line
    or read from a script.
-}

-- Command errors correspond to different "stages" in attempted execution:
data CmdError  =
               -- Stage (1) errors: command is not understood
                  LexErr      LexError            -- Lexical error
               |  InvalidCmd  String Pos          -- Command not recognised by any command matcher
               |  ScriptErr   String [CmdError]   -- Multiple LexErr/InvalidCmd from parsing scripts

               -- Stage (2) and (4) errors: (2) command's parameters have the wrong type,
               --                           (4) command's parameters are semantically incorrect
               |  ParamErr    [ParamError]

               -- Stage (3) errors: command is not safe to apply in the current proof state
               |  RelationErr String

               -- Stage (5) errors: command is invalid in the current interpreter context
               |  StateErr    InterState          -- The command cannot be executed in the
                                                  -- current interpreter state
               |  LibErr      String              -- Invalid/missing library param. etc.
               |  FileErr     String              -- Incorrect filepath param. etc.
               |  HistErr     String              -- Invalid history request e.g., update
               |  KureErr     String              -- Errors generated by KURE when applying
                                                  -- a command's underlying AST rewrite
               |  CtxKindErr  String              -- Invalid CtxKind
               |  EnvErr      String              -- Environment error

               -- Internal errors: my implementation went wrong
               |  InternalErr InternalError

instance Show CmdError where
  show (LexErr err)          = outputError . ("Lexical error: " ++) $ show err
  show (InvalidCmd s _)      = outputError $ ("Invalid command: " ++ s)
  show (ScriptErr _ cmdErrs) = outputError' "Script error(s):" sCmdErrs
    where sCmdErrs           = unlines' $ fmap show cmdErrs
  show (ParamErr parErrs)    = outputError' "Parameter error(s):" sParErrs
    where sParErrs           = unlines' $ fmap show parErrs
  show (RelationErr s)       = outputError $ "Relation error: " ++ s
  show (StateErr _)          = outputError $ "Error: command not available in this program mode."
  show (FileErr s)           = outputError s
  show (LibErr s)            = outputError s
  show (HistErr s)           = outputError s
  show (KureErr s)           = outputError $ "Error: " ++ dropKureInfo s
  show (CtxKindErr s)        = outputError s
  show (EnvErr s)            = outputError s
  show (InternalErr ie)      = outputCritError $ show ie

{-
  - The command parsing process accepts parameters in *any* order;
  - Thus
      > cmd p1 p2
      > cmd p2 p1
    will be parsed to the same command unless p1 and p2 have the same type
    and the order of p1 and p2 have a semantic impact on the command. As
    it currently stands, I have no examples of this because such a situation
    doesn't arise in UNIEs use cases. However, in this situation, the command
    would be parsed such that its semantic meaning reflects the order of
    order of the arguments as they appear on the command line. Hence
      > cmd p1 p2
    would be parsed to reflect the order p1 p2, despite p2 p1 also being a
    valid interpretation of the command.
  - Note MultiParseSuccess errors do not arise from the above scenario,
    as the same matching/refining function would consume the command
    in two different ways.
  - As we allow parameters to appear in any order, it is more difficult
    to report missing/additional parameters precisely. At this stage the
    system does it's best to report the most appropriate error but
    often doesn't perform terrifically.
-}
data ParamError  =  InvalidParam String Pos
                 |  ExtraParam   String Pos
                 |  MissingParam String
                    deriving Eq

instance Show ParamError where
  show (InvalidParam s pos) = outputError $ show pos ++ " " ++ s
  show (ExtraParam s pos)   = outputError $ "Extra param: " ++ show pos ++ " " ++ s
  show (MissingParam s)     = outputError $ "Missing param: " ++ s

-- Internal errors report implementation errors
-- So they "should" never occur 8-)
data InternalError  =  NoRefine         String           -- No refine function available
                    |  WrongRefine      String           -- Wrong refine function used
                    |  NoInter          String           -- No interpreter function available
                    |  WrongInter       String           -- Wrong interpreter function used
                    |  UnexpectedParams String [String]  -- Failed interpretation due to unexpected params
                                                         --  => should have been rejected by refinement
                    |  UnexpectedCmd    String String    -- Failed interpretation due to unexpected cmd.
                                                         --  => should have been rejected by refinement
                    |  IOErr            String           -- IO Errors from Haskeline
                    |  MultiParseSuccess                 -- If multiple, distinct parsers/refiners consume
                                                         -- a command.
                       deriving Show

-- Helpers: -------------------------------------------------------------------

{-
   The current implementation produces multiple lists of parameter errors when
   matchers fail to parse a command. This is due to them attempting to match
   parameters in different orders. We only want to report one list of errors
   to the user, so we return the one whereby the most parameters have been
   successfully parsed. In the event that all matchers return a single
   parameter error (i.e., a singleton list), we combine the lists because
   it is likely to be a missing/extra parameter.

   <TO-DO> this could do with some more work
-}
sortParamErrors     ::  [[ParamError]] -> [ParamError]
sortParamErrors []   =  []
sortParamErrors pss  =  fromMaybe (head bestErrors) (combine bestErrors)
                        where
                             bestErrors = nub $ filter (\ps -> length ps == minErrors) pss
                             minErrors  = minimum (fmap length pss)

                             -- Combine singleton errors of the same kind
                             combine pss | allEq (fmap (fmap toIdx) pss) &&
                                            and (fmap singleton pss) = Just [ p | [p] <- pss]
                                         | otherwise                 = Nothing

                             -- Index then to compare against
                             toIdx InvalidParam{}  =  0 :: Int
                             toIdx ExtraParam{}    =  1 :: Int
                             toIdx MissingParam{}  =  2 :: Int

-- Output error message to terminal width, highlighted red.
outputError :: String -> String
outputError = unlines' . highlightError . squashString (terminalLineWidth - 2)

-- Output error message to terminal width, highlighted red.
outputCritError :: String -> String
outputCritError = unlines' . highlightCritError . squashString (terminalLineWidth - 2)

-- As above, but we have an additional line at the top.
outputError' :: String -> String -> String
outputError' title s = unlines' [highTitle, indentHighlightError s] -- unlines' errs
  where highTitle = unlines' $ highlightError [title]

-- Drop the Kure fail information from error messages for now.
dropKureInfo :: String -> String
dropKureInfo s = stripSpace . unwords $  (fmap (\s -> s ++ ":") l) ++ r
 where
      ss = filter (\s -> not $ "failed" `isInfixOf` s) . splitOn ":" $ s
      (l, r) = splitAt (length ss - 1) ss
